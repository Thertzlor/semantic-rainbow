<!DOCTYPE html>
<html>

<head>
   <meta charset='utf-8'>
   <meta http-equiv='X-UA-Compatible' content='IE=edge'>
   <title>Semantic Rainbow</title>
   <meta name='viewport' content='width=device-width, initial-scale=1'>
   <link href="https://fonts.googleapis.com/css?family=Fira+Sans:300,400,500,600" rel="stylesheet">
   <script src='./generator/lib/tinycolor.js'></script>
   <script type="module">
      import {generateColors, interpolate} from './generator/lib/colorGenerator.js';
      //We need to fetch the JSON configuration file via HTTP
      const getConfig = new Promise((res, rej) => {
         const Http = new XMLHttpRequest();
         Http.open("GET", './generator/config.json');
         Http.send();
         Http.onreadystatechange = e => {
            if (Http.readyState === 4 && Http.status === 200) res(Http.responseText)
            else if (Http.readyState === 4) rej(Http.responseText)
         }
      });

      (async () => {
         const {themes} = JSON.parse(await getConfig);
         const frag = new DocumentFragment();
         //Only using the stats from the main Theme
         const {semanticRules, meta} = generateColors(tinycolor, themes.find(t => themes.length === 1 || t.mainTheme));
         //Filling in variables into the text;
         [...document.getElementsByClassName('text')].forEach(e => e.innerHTML = interpolate(e.innerHTML, meta));
         //Creating the color table
         const myTable = frag.appendChild(document.createElement('table')).appendChild(document.createElement('tbody'));
         let tableContainer;
         let lastKey = '';
         for (const k in semanticRules) {
            //We only output a demo for the main token type, not for any aliases
            if ((!Object.hasOwnProperty.call(semanticRules, k)) || semanticRules[k].alias) continue;
            const styleElement = semanticRules[k];
            const keyArray = k.split('.');
            const firstKey = keyArray[0]
            //If the token type has changed, insert a new row into the table
            if (lastKey !== firstKey) {
               tableContainer = myTable.appendChild(document.createElement('tr'))
               //The first cell contains the token name
               tableContainer.appendChild(document.createElement('td')).innerHTML = firstKey;
            }
            lastKey = firstKey;
            const colorValue = styleElement.foreground || styleElement
            const tableSquare = tableContainer.appendChild(document.createElement('td'))
            //Generating the tooltip element for the individual cells
            const tooltip = tableSquare.appendChild(document.createElement('div'))
            tooltip.classList.add('expl')
            //HTML formatting for the token description
            tooltip.innerHTML = (k.replace(/\./g, '\n<br>')).split('\n').map((e, i) => i === 0 ? e : `<i>${e}</i>`).join('\n') + `\n<p style="color:${colorValue}; ${k.includes('declaration') ? 'font-style:italic;' : ''} text-shadow:none;">${colorValue}</p>`;
            tableSquare.style.background = colorValue;
            tableSquare.classList.add('tableSquare')
         }
         //Showing the table
         document.getElementById("colorTable").appendChild(frag)

      })()

   </script>
   <style>
      * {
         box-sizing: border-box;
         color: white;
         text-shadow: 2px 2px 5px black, 0px 0px 2px black;
      }

      table {
         margin: 0 auto;
         border-spacing: .4vw;
      }

      .tableSquare {
         border: .2vmax transparent solid;
         margin: 5px;
         width: 3vw;
         position: relative;
         transition: border-color .3s ease-in-out;
      }

      .tableSquare .expl {
         line-height: 140%;
         z-index: 4000;
         position: absolute;
         opacity: 0;
         display: block;
         overflow: hidden;
         transition: opacity .4s, right .2s, bottom .2s;
         bottom: 40%;
         right: 40%;
         pointer-events: none;
         background: #15161f;
         box-shadow: 1px 1px 6px rgba(0, 0, 0, 0.3);
         padding: 10px;
         border: 3px solid #595e75;
         border-radius: 5px;
      }

      .tableSquare:hover {

         border-color: white;
      }

      .tableSquare:hover .expl {
         opacity: 1;
         right: 50%;
         bottom: 50%;
      }

      .tableSquare p {
         margin: 0;

      }

      .tableSquare::after {
         content: '';
         display: block;
         padding-top: 100%;
      }

      h1,
      h2,
      h3 {
         text-align: center;
      }

      body.bod {
         padding-bottom: 3%
      }

      body,
      html {
         margin: 0;
         padding: 0;
         font-family: 'Fira Sans', Calibri, sans-serif;
         font-weight: 500;
         font-size: 1vmax;
         background: #191a26;
      }

      .text {
         font-weight: 400;
         width: 90vw;
         margin: 0 auto;
      }

      .text h3 {
         font-weight: 400;
      }

      .ctx {
         text-align: center
      }
   </style>
</head>

<body class="bod">
   <h1>Semantic Rainbow</h1>
   <h3 class="text"> A {manualPercent}% hand crafted Color Theme for Visual Studio Code</h2>
      <h2>Colors</h2>
      <p class="ctx">[Hover for details]</p>
      <div id="colorTable"></div>

      <div class="text">
         <h2 id="faq">FAQ</h2>
         <p> <em>Q: Are that many colors really neccessary?</em><br>A: No, absolutely not. Some of them are in fact completely ludicrous.<br>For example if you know any language in which <em>static async enum members</em> are a thing I would love to see it.
            On the bright side, that means that not every single color needs to be the most beautiful tone, and that I don&#39;t need to worry about teh contrast between some colors if one of them is a super weird or even impossible edge case.</p>
         <p><em>Q: I can&#39;t get the private token modifier in TypeScript to work, am I doing something wrong?</em>
            A: No, the private modifier isn&#39;t implemented in the Typescript language server yet</p>
         <p> <em>Q: Some of those colors seem pretty close to each other, is it really possible to tell them apart?</em><br> A: It is true that some colors would be hard to distinguish in <em>isolation</em> but in actual code tokens are literally surrounded by context. You&#39;d be surprised how many slight differences you pick up subconsciously after a while.</p>
         <p><em>Q: But some of them seem pretty much identical?</em><br>A: That would be the declaration styles. That&#39;s because they are mainly differentiated from other tokens by being shown in <em>italics</em>.</p>
         <p><em>Q: With which languages have you tested this theme?</em><br>A: I am mainly testing this new changes in TypeScript
            are Python, CSS/SCSS, HTML, twig, </p>
         <h2 id="design-philosophy">Design Philosophy</h2>
         <p>I am not going to pretend that I went into this with a definite concept and a background in color psychology. Many of these color associations emerged basically on their own as I was tweaking colors back and forth and later I went back to figure out <em>how</em> they might work.</p>
         <h3 id="red-valuesinformation"><strong>Red:</strong> Values/Information</h3>
         <h3 id="purple-keywordsflow-control"><strong>Purple:</strong> keywords/flow control</h3>
         <h3 id="blue-actiontransformation"><strong>Blue:</strong> Action/Transformation</h3>
         <h3 id="green-statestorage"><strong>Green:</strong> State/Storage</h3>
         <h3 id="yellow-static-definitionsspecific-values"><strong>Yellow:</strong> Static Definitions/specific values</h3>
         <p>And finally...</p>
         <h3 id="saturation-is-associated-to-mutability"><strong>Saturation</strong> is associated to mutability.</h3>
         <p>That designates a definition or action for the tokens around itself.</p>
         <p>Whenever you see red, you know information is being accessed and processed</p>
         <p>Parameters are orange because in addition to storing values like regular variables they veer in the direction of statefullness (green), as they represent the specific state of a single execution of a function.</p>
         <p>For example methods are midway between the blue of functions and the green of classes, representing them being being influenced a specific state moreso than normal functions</p>
         <p>Basically just to distinguish them from normal objects and namespaces.</p>


      </div>

</body>

</html>